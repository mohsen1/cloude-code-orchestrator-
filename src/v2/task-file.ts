/**
 * TaskFile - Markdown task file generator
 *
 * Generates WORKER_N_TASK.md files that Claude reads to understand its task.
 * This is the file-based protocol for task communication.
 */

import { writeFile, readFile, unlink } from 'fs/promises';
import { join } from 'path';
import { logger } from '../utils/logger.js';
import type { Task, Team, OrchestratorMode } from './types.js';

/** Task file name pattern */
export function getTaskFileName(workerId: number): string {
  return `WORKER_${workerId}_TASK.md`;
}

/** EM task file name pattern */
export function getEmTaskFileName(teamId: number): string {
  return `EM_${teamId}_TASK.md`;
}

/** Director task file name */
export const DIRECTOR_TASK_FILE = 'DIRECTOR_TASK.md';

/** Manager task file name (flat mode) */
export const MANAGER_TASK_FILE = 'MANAGER_TASK.md';

/**
 * Generate a worker task file content
 */
export function generateWorkerTaskContent(
  task: Task,
  workerId: number,
  context: {
    branchName: string;
    baseBranch: string;
    teamInfo?: string;
    mode: OrchestratorMode;
  }
): string {
  const requirements = task.requirements?.length
    ? task.requirements.map((r) => `- ${r}`).join('\n')
    : '- Complete the task as described';

  const filesToModify = task.filesToModify?.length
    ? task.filesToModify.map((f) => `- ${f}`).join('\n')
    : '- Determine which files need modification based on the task';

  const acceptanceCriteria = task.acceptanceCriteria?.length
    ? task.acceptanceCriteria.map((c) => `- [ ] ${c}`).join('\n')
    : '- [ ] Task completed successfully\n- [ ] Code compiles/builds without errors\n- [ ] Tests pass (if applicable)';

  return `# Worker ${workerId} Task

## Current Task

**${task.title}**

${task.description}

## Requirements

${requirements}

## Files to Modify

${filesToModify}

## Acceptance Criteria

${acceptanceCriteria}

## Context

- **Branch:** ${context.branchName}
- **Base Branch:** ${context.baseBranch}
- **Mode:** ${context.mode}
${context.teamInfo ? `- **Team:** ${context.teamInfo}` : ''}
- **Task ID:** ${task.id}
- **Priority:** ${task.priority}

## Instructions

1. Read and understand the task requirements above
2. Make changes incrementally with clear, descriptive commit messages
3. Test your changes before marking the task complete
4. Do not modify files outside your task scope unless necessary
5. When done, commit all changes and push to your branch

Your changes will be automatically merged after review.

---
*Generated by CCO at ${new Date().toISOString()}*
`;
}

/**
 * Generate an EM (Engineering Manager) task file for reviewing worker changes
 */
export function generateEmTaskContent(
  teamId: number,
  workerBranches: string[],
  targetBranch: string
): string {
  const branchList = workerBranches.map((b) => `- ${b}`).join('\n');

  return `# Engineering Manager ${teamId} Task

## Role

You are the Engineering Manager for Team ${teamId}. Your job is to:
1. Review changes from workers in your team
2. Merge approved changes to your team branch
3. Ensure code quality and consistency
4. Resolve merge conflicts if they occur

## Worker Branches to Review

${branchList}

## Target Branch

${targetBranch}

## Instructions

For each worker branch:

1. **Fetch latest changes:**
   \`\`\`bash
   git fetch origin <worker-branch>
   \`\`\`

2. **Review the diff:**
   \`\`\`bash
   git diff ${targetBranch}...origin/<worker-branch> --stat
   git diff ${targetBranch}...origin/<worker-branch>
   \`\`\`

3. **If changes look good, merge:**
   \`\`\`bash
   git merge --no-ff origin/<worker-branch> -m "Merge <worker-branch>"
   \`\`\`

4. **If there are conflicts:**
   - Review conflicting files
   - Resolve conflicts keeping the best of both changes
   - Stage resolved files: \`git add <file>\`
   - Complete merge: \`git commit\`

5. **Push merged changes:**
   \`\`\`bash
   git push origin ${targetBranch}
   \`\`\`

## Quality Checklist

- [ ] Code follows project conventions
- [ ] No obvious bugs or issues
- [ ] Changes match the task requirements
- [ ] Tests pass (if applicable)

---
*Generated by CCO at ${new Date().toISOString()}*
`;
}

/**
 * Generate a Director task file for coordinating teams
 */
export function generateDirectorTaskContent(
  teams: Team[],
  mainBranch: string
): string {
  const teamList = teams
    .map((t) => `- **Team ${t.id}:** Branch \`${t.branchName}\` (EM: ${t.emId}, Workers: ${t.workerIds.join(', ')})`)
    .join('\n');

  return `# Director Task

## Role

You are the Director coordinating multiple engineering teams. Your job is to:
1. Monitor progress across all teams
2. Merge team branches to main when ready
3. Coordinate cross-team dependencies
4. Ensure overall project quality

## Teams

${teamList}

## Main Branch

${mainBranch}

## Instructions

### Monitoring

Check each team's progress:
\`\`\`bash
git fetch origin
git log ${mainBranch}..origin/<team-branch> --oneline
\`\`\`

### Merging Team Branches

When a team has completed work:

1. **Review the team's changes:**
   \`\`\`bash
   git diff ${mainBranch}...origin/<team-branch> --stat
   \`\`\`

2. **If ready, merge to main:**
   \`\`\`bash
   git checkout ${mainBranch}
   git merge --no-ff origin/<team-branch> -m "Merge team branch"
   git push origin ${mainBranch}
   \`\`\`

3. **If conflicts, coordinate with EM to resolve**

### Cross-Team Coordination

If multiple teams modify the same files:
1. Identify the conflict early
2. Coordinate merge order with EMs
3. Ensure proper conflict resolution

---
*Generated by CCO at ${new Date().toISOString()}*
`;
}

/**
 * Generate a Manager task file for flat mode
 */
export function generateManagerTaskContent(
  workerBranches: string[],
  mainBranch: string
): string {
  const branchList = workerBranches.map((b) => `- ${b}`).join('\n');

  return `# Manager Task

## Role

You are the Manager coordinating workers in flat mode. Your job is to:
1. Review changes from all workers
2. Merge approved changes to main
3. Ensure code quality and consistency
4. Resolve merge conflicts if they occur

## Worker Branches to Review

${branchList}

## Main Branch

${mainBranch}

## Instructions

For each worker branch with new commits:

1. **Fetch and check for new commits:**
   \`\`\`bash
   git fetch origin <worker-branch>
   git log ${mainBranch}..origin/<worker-branch> --oneline
   \`\`\`

2. **If there are new commits, review:**
   \`\`\`bash
   git diff ${mainBranch}...origin/<worker-branch> --stat
   git diff ${mainBranch}...origin/<worker-branch>
   \`\`\`

3. **If changes look good, merge:**
   \`\`\`bash
   git merge --no-ff origin/<worker-branch> -m "Merge worker-N"
   git push origin ${mainBranch}
   \`\`\`

4. **If conflicts, resolve them:**
   - Review conflicting files
   - Keep the best of both changes
   - Stage and commit resolved files

## Quality Checklist

- [ ] Code follows project conventions
- [ ] No obvious bugs or issues
- [ ] Changes match the task requirements

---
*Generated by CCO at ${new Date().toISOString()}*
`;
}

/**
 * Write a task file to a worktree
 */
export async function writeTaskFile(
  worktreePath: string,
  fileName: string,
  content: string
): Promise<string> {
  const filePath = join(worktreePath, fileName);

  await writeFile(filePath, content, 'utf-8');

  logger.debug('Task file written', { filePath, contentLength: content.length });

  return filePath;
}

/**
 * Read a task file from a worktree
 */
export async function readTaskFile(
  worktreePath: string,
  fileName: string
): Promise<string | null> {
  const filePath = join(worktreePath, fileName);

  try {
    return await readFile(filePath, 'utf-8');
  } catch (error) {
    logger.debug('Task file not found', { filePath });
    return null;
  }
}

/**
 * Delete a task file from a worktree
 */
export async function deleteTaskFile(
  worktreePath: string,
  fileName: string
): Promise<boolean> {
  const filePath = join(worktreePath, fileName);

  try {
    await unlink(filePath);
    logger.debug('Task file deleted', { filePath });
    return true;
  } catch (error) {
    logger.debug('Failed to delete task file', { filePath });
    return false;
  }
}
